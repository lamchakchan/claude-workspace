// Package statusline implements the "statusline" command, which configures the
// Claude Code status bar to display session cost, context usage, model name,
// and weekly subscription reset countdown.
package statusline

import (
	"fmt"
	"os"
	"path/filepath"

	"github.com/lamchakchan/claude-workspace/internal/platform"
)

// wrapperScript is written to ~/.claude/statusline.sh.
// It combines ccusage (or jq fallback) with a weekly reset countdown derived
// from the subscriptionCreatedAt field in ~/.claude.json.
const wrapperScript = `#!/usr/bin/env bash
# Auto-generated by claude-workspace statusline — do not edit manually.
# Combines ccusage (or jq fallback) with weekly subscription reset countdown.

input=$(cat)

# Base statusline: runtime detected at execution time
if command -v bun &>/dev/null; then
    base=$(printf '%s' "$input" | bun x ccusage statusline 2>/dev/null)
elif command -v npx &>/dev/null; then
    base=$(printf '%s' "$input" | npx -y ccusage statusline 2>/dev/null)
else
    base=$(printf '%s' "$input" | jq -r \
        '"\(.model.display_name) | $\(.cost.total_cost_usd | . * 1000 | round / 1000) | \(.context_window.used_percentage)% ctx"' \
        2>/dev/null)
fi

# Weekly reset countdown from ~/.claude.json (requires python3)
reset=$(python3 - <<'PYEOF' 2>/dev/null
import json, datetime, pathlib
try:
    data = json.loads((pathlib.Path.home() / '.claude.json').read_text())
    sub_str = data.get('oauthAccount', {}).get('subscriptionCreatedAt', '')
    if not sub_str:
        raise SystemExit
    sub = datetime.datetime.fromisoformat(sub_str.replace('Z', '+00:00'))
    now = datetime.datetime.now(datetime.timezone.utc)
    days = (sub.weekday() - now.weekday()) % 7
    if days == 0:
        print('resets today')
    elif days == 1:
        print('resets tomorrow')
    else:
        print(f'resets in {days}d')
except Exception:
    pass
PYEOF
)

# Service status alerts (cached, 5-minute TTL)
# Supports: Atlassian Statuspage (GitHub, Claude, Cloudflare),
#           AWS Health, Google Cloud, Azure DevOps
status_alerts=$(python3 - <<'PYEOF' 2>/dev/null
import json, os, time, urllib.request
CACHE_DIR = os.path.join(os.environ.get('TMPDIR', '/tmp'), 'claude-statusline')
os.makedirs(CACHE_DIR, exist_ok=True)
RED = "\033[1;31m"
YLW = "\033[1;33m"
RST = "\033[0m"

def fetch_cached(label, url, ttl=300):
    cache = os.path.join(CACHE_DIR, label.lower().replace(" ", "-") + "-status.json")
    try:
        if not os.path.exists(cache) or time.time() - os.path.getmtime(cache) > ttl:
            req = urllib.request.Request(url, headers={"User-Agent": "claude-statusline"})
            with urllib.request.urlopen(req, timeout=2) as r:
                with open(cache, 'wb') as f:
                    f.write(r.read())
    except Exception:
        pass
    try:
        with open(cache) as f:
            return json.load(f)
    except Exception:
        return None

def color(severity, text):
    if severity == "major":
        return "\U0001f6a8 " + RED + text + RST
    return "\u26a0\ufe0f  " + YLW + text + RST

alerts = []

# Atlassian Statuspage services (GitHub, Claude, Cloudflare)
for label, url in [
    ("GitHub", "https://www.githubstatus.com/api/v2/status.json"),
    ("Claude", "https://status.claude.com/api/v2/status.json"),
    ("Cloudflare", "https://www.cloudflarestatus.com/api/v2/status.json"),
]:
    data = fetch_cached(label, url)
    if data:
        ind = data.get("status", {}).get("indicator", "none")
        desc = data.get("status", {}).get("description", "")
        if ind != "none":
            sev = "major" if ind in ("major", "critical") else "minor"
            alerts.append(color(sev, label + ": " + desc))

# AWS — empty array means healthy, non-empty means active incidents
data = fetch_cached("aws", "https://health.aws.amazon.com/public/currentevents")
if data and isinstance(data, list) and len(data) > 0:
    alerts.append(color("major", "AWS: Active Incidents (" + str(len(data)) + ")"))

# Google Cloud — active incidents where latest status is not AVAILABLE
data = fetch_cached("google-cloud", "https://status.cloud.google.com/incidents.json")
if data and isinstance(data, list):
    active = [i for i in data if i.get("most_recent_update", {}).get("status") not in ("AVAILABLE", None)]
    if active:
        sev = "major" if any(i.get("severity") == "high" for i in active) else "minor"
        alerts.append(color(sev, "Google Cloud: Active Incidents (" + str(len(active)) + ")"))

# Azure DevOps — status.health != "healthy"
data = fetch_cached("azure-devops", "https://status.dev.azure.com/_apis/status/health?api-version=7.1-preview.1")
if data:
    health = data.get("status", {}).get("health", "healthy")
    msg = data.get("status", {}).get("message", "Issues detected")
    if health != "healthy":
        sev = "major" if health == "unhealthy" else "minor"
        alerts.append(color(sev, "Azure DevOps: " + msg))

if alerts:
    print("  ".join(alerts))
PYEOF
)

# Combine and output — alerts on line 1, base statusline on line 2
result=""
if [[ -n "$base" && -n "$reset" ]]; then
    result="${base%$'\n'} | $reset"
elif [[ -n "$base" ]]; then
    result="${base%$'\n'}"
fi
if [[ -n "$status_alerts" && -n "$result" ]]; then
    printf '%b\n%s\n' "$status_alerts" "$result"
elif [[ -n "$status_alerts" ]]; then
    printf '%b\n' "$status_alerts"
elif [[ -n "$result" ]]; then
    printf '%s\n' "$result"
fi
`

// Run is the entry point for the statusline command.
// args is os.Args[2:] (everything after "statusline").
func Run(args []string) error {
	force := false
	for _, a := range args {
		if a == "--force" {
			force = true
		}
	}
	return configure(force)
}

// configure writes ~/.claude/statusline.sh and registers it in ~/.claude/settings.json.
func configure(force bool) error {
	home, err := os.UserHomeDir()
	if err != nil {
		return fmt.Errorf("getting home directory: %w", err)
	}

	claudeDir := filepath.Join(home, ".claude")
	if err := os.MkdirAll(claudeDir, 0755); err != nil {
		return fmt.Errorf("creating ~/.claude: %w", err)
	}

	settingsPath := filepath.Join(claudeDir, "settings.json")

	var settings map[string]interface{}
	if platform.FileExists(settingsPath) {
		if err := platform.ReadJSONFile(settingsPath, &settings); err != nil {
			return fmt.Errorf("reading settings: %w", err)
		}
	} else {
		settings = make(map[string]interface{})
	}

	if !force {
		if _, exists := settings["statusLine"]; exists {
			platform.PrintOK(os.Stdout, "statusLine already configured in ~/.claude/settings.json (use --force to overwrite)")
			return nil
		}
	}

	scriptPath := filepath.Join(claudeDir, "statusline.sh")
	if err := writeWrapperScript(scriptPath); err != nil {
		return fmt.Errorf("writing statusline script: %w", err)
	}
	fmt.Printf("  Script written: %s\n", scriptPath)

	cmd := "bash " + scriptPath
	settings["statusLine"] = map[string]interface{}{
		"type":    "command",
		"command": cmd,
		"padding": 0,
	}

	if err := platform.WriteJSONFile(settingsPath, settings); err != nil {
		return fmt.Errorf("writing settings: %w", err)
	}

	platform.PrintOK(os.Stdout, "statusLine configured in ~/.claude/settings.json")
	fmt.Println("  Restart Claude Code to activate the statusline.")
	return nil
}

// writeWrapperScript writes the statusline shell script to the given path.
func writeWrapperScript(path string) error {
	return os.WriteFile(path, []byte(wrapperScript), 0755)
}
