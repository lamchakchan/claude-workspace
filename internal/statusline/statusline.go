// Package statusline implements the "statusline" command, which configures the
// Claude Code status bar to display session cost, context usage, model name,
// and weekly subscription reset countdown.
package statusline

import (
	"fmt"
	"os"
	"path/filepath"

	"github.com/lamchakchan/claude-workspace/internal/platform"
)

// wrapperScript is written to ~/.claude/statusline.sh.
// It combines ccusage (or jq fallback) with a weekly reset countdown derived
// from the subscriptionCreatedAt field in ~/.claude.json.
const wrapperScript = `#!/usr/bin/env bash
# Auto-generated by claude-workspace statusline â€” do not edit manually.
# Combines ccusage (or jq fallback) with weekly subscription reset countdown.

input=$(cat)

# Base statusline: runtime detected at execution time
if command -v bun &>/dev/null; then
    base=$(printf '%s' "$input" | bun x ccusage statusline 2>/dev/null)
elif command -v npx &>/dev/null; then
    base=$(printf '%s' "$input" | npx -y ccusage statusline 2>/dev/null)
else
    base=$(printf '%s' "$input" | jq -r \
        '"\(.model.display_name) | $\(.cost.total_cost_usd | . * 1000 | round / 1000) | \(.context_window.used_percentage)% ctx"' \
        2>/dev/null)
fi

# Weekly reset countdown from ~/.claude.json (requires python3)
reset=$(python3 - <<'PYEOF' 2>/dev/null
import json, datetime, pathlib
try:
    data = json.loads((pathlib.Path.home() / '.claude.json').read_text())
    sub_str = data.get('oauthAccount', {}).get('subscriptionCreatedAt', '')
    if not sub_str:
        raise SystemExit
    sub = datetime.datetime.fromisoformat(sub_str.replace('Z', '+00:00'))
    now = datetime.datetime.now(datetime.timezone.utc)
    days = (sub.weekday() - now.weekday()) % 7
    if days == 0:
        print('resets today')
    elif days == 1:
        print('resets tomorrow')
    else:
        print(f'resets in {days}d')
except Exception:
    pass
PYEOF
)

# Combine and output
if [[ -n "$base" && -n "$reset" ]]; then
    printf '%s | %s\n' "${base%$'\n'}" "$reset"
elif [[ -n "$base" ]]; then
    printf '%s\n' "$base"
fi
`

// Run is the entry point for the statusline command.
// args is os.Args[2:] (everything after "statusline").
func Run(args []string) error {
	force := false
	for _, a := range args {
		if a == "--force" {
			force = true
		}
	}
	return configure(force)
}

// configure writes ~/.claude/statusline.sh and registers it in ~/.claude/settings.json.
func configure(force bool) error {
	home, err := os.UserHomeDir()
	if err != nil {
		return fmt.Errorf("getting home directory: %w", err)
	}

	claudeDir := filepath.Join(home, ".claude")
	if err := os.MkdirAll(claudeDir, 0755); err != nil {
		return fmt.Errorf("creating ~/.claude: %w", err)
	}

	settingsPath := filepath.Join(claudeDir, "settings.json")

	var settings map[string]interface{}
	if platform.FileExists(settingsPath) {
		if err := platform.ReadJSONFile(settingsPath, &settings); err != nil {
			return fmt.Errorf("reading settings: %w", err)
		}
	} else {
		settings = make(map[string]interface{})
	}

	if !force {
		if _, exists := settings["statusLine"]; exists {
			platform.PrintOK(os.Stdout, "statusLine already configured in ~/.claude/settings.json (use --force to overwrite)")
			return nil
		}
	}

	scriptPath := filepath.Join(claudeDir, "statusline.sh")
	if err := writeWrapperScript(scriptPath); err != nil {
		return fmt.Errorf("writing statusline script: %w", err)
	}
	fmt.Printf("  Script written: %s\n", scriptPath)

	cmd := "bash " + scriptPath
	settings["statusLine"] = map[string]interface{}{
		"type":    "command",
		"command": cmd,
		"padding": 0,
	}

	if err := platform.WriteJSONFile(settingsPath, settings); err != nil {
		return fmt.Errorf("writing settings: %w", err)
	}

	platform.PrintOK(os.Stdout, "statusLine configured in ~/.claude/settings.json")
	fmt.Println("  Restart Claude Code to activate the statusline.")
	return nil
}

// writeWrapperScript writes the statusline shell script to the given path.
func writeWrapperScript(path string) error {
	return os.WriteFile(path, []byte(wrapperScript), 0755)
}
